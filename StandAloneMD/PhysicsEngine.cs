// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
namespace StandAloneMD
{
	public class PhysicsEngine
	{
		public PhysicsEngine ()
		{
		}

		public static void VelocityVerlet()
		{
			// update the position of all atoms then initialize the acceleration to be updated
			for (int i=0; i< Atom.AllAtoms.Count; i++)
            {
				Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    currAtom.position[idx] = currAtom.position[idx] + currAtom.velocity [idx] * StaticVariables.MDTimestep + 0.5f * StaticVariables.MDTimestepSqr * currAtom.accelerationNew [idx];
                }
                currAtom.accelerationOld = currAtom.accelerationNew;
                currAtom.accelerationNew = new float[3] { 0.0f, 0.0f, 0.0f };
			}

			// update the acceleration of all atoms
			for (int i=0; i< Atom.AllAtoms.Count-1; i++) {
				Atom firstAtom = Atom.AllAtoms[i];
				for (int j=i+1; j<Atom.AllAtoms.Count; j++) {
					Atom secondAtom = Atom.AllAtoms[j];
                    GetLennardJonesForce(firstAtom, secondAtom);
				}
			}

            // update the velocity of all atoms
            for (int i = 0; i < Atom.AllAtoms.Count; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    currAtom.velocity[idx] = currAtom.velocity[idx] + 0.5f * (currAtom.accelerationOld[idx] + currAtom.accelerationNew[idx]) * StaticVariables.MDTimestep;
                }
            }
		}

		//the function returns the Lennard-Jones force on the atom given the list of all the atoms in the simulation
		private static void GetLennardJonesForce(Atom firstAtom, Atom secondAtom)
		{
			float[] firstAtomAcceleration = new float[3];
            float[] secondAtomAcceleration = new float[3];

            float[] deltaR = new float[3];
            for (int idx = 0; idx < 3; idx++)
            {
                deltaR[idx] = firstAtom.position[idx] - secondAtom.position[idx];
            }
			float distanceSqr = deltaR[0] * deltaR[0] + deltaR[1] *deltaR[1] + deltaR[2] * deltaR[2];
			float finalSigma = StaticVariables.sigmaValues [firstAtom.atomID, secondAtom.atomID];
			float normDistanceSqr = distanceSqr / finalSigma / finalSigma; // this is normalized distanceSqr to the sigmaValue
				
			//only get the forces of the atoms that are within the cutoff range
			if (normDistanceSqr <= StaticVariables.cutoffSqr) 
			{
				int iR = (int) ((float)Math.Sqrt(normDistanceSqr)/(StaticVariables.deltaR));
                for (int idx = 0; idx < 3; idx++)
                {
                    firstAtom.accelerationNew[idx] = firstAtom.accelerationNew[idx] + StaticVariables.preLennardJones[iR] * StaticVariables.accelCoefficient[firstAtom.atomID,secondAtom.atomID] * deltaR[idx];
                    secondAtom.accelerationNew[idx] = secondAtom.accelerationNew[idx] - StaticVariables.preLennardJones[iR] * StaticVariables.accelCoefficient[secondAtom.atomID, firstAtom.atomID] * deltaR[idx];
                }
			}
		}

        //reflect the atoms from the walls
        public static void ReflectFromWalls()
        {
            for (int i = 0; i < Atom.AllAtoms.Count; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    currAtom.position[idx] = currAtom.position[idx] + currAtom.velocity[idx] * StaticVariables.MDTimestep + 0.5f * StaticVariables.MDTimestepSqr * currAtom.accelerationNew[idx];
                }
            }

        }
	}
}

