// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
namespace StandAloneMD
{
	public class PhysicsEngine
	{

		public static void VelocityVerlet()
		{
			// update the position of all atoms then initialize the acceleration to be updated
			for (int i=0; i< Atom.AllAtoms.Count; i++)
            {
				Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    currAtom.position[idx] = currAtom.position[idx] + currAtom.velocity [idx] * StaticVariables.MDTimestep + 0.5f * StaticVariables.MDTimestepSqr * currAtom.accelerationNew [idx];
                }
                currAtom.accelerationOld = currAtom.accelerationNew;
                currAtom.accelerationNew = new float[3] { 0.0f, 0.0f, 0.0f };
			}

			// update the acceleration of all atoms
			for (int i=0; i< Atom.AllAtoms.Count-1; i++) {
				Atom firstAtom = Atom.AllAtoms[i];
                
                /*
                for (int j = i+1; j < Atom.AllAtoms.Count; j++)
                {
                    Atom secondAtom = Atom.AllAtoms[j];
                    getLennardJonesForce(firstAtom, secondAtom);
                }
                */
                
                for (int j=0; j<firstAtom.neighborList.Count; j++) {
					Atom secondAtom = firstAtom.neighborList[j];
                    getLennardJonesForce(firstAtom, secondAtom);
				}
			}

            // update the velocity of all atoms
            for (int i = 0; i < Atom.AllAtoms.Count; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    currAtom.velocity[idx] = currAtom.velocity[idx] + 0.5f * (currAtom.accelerationOld[idx] + currAtom.accelerationNew[idx]) * StaticVariables.MDTimestep;
                    currAtom.velocity[idx] = currAtom.velocity[idx] * StaticVariables.sqrtAlpha;
                }
            }
		}

		//the function returns the Lennard-Jones force on the atom given the list of all the atoms in the simulation
		private static void getLennardJonesForce(Atom firstAtom, Atom secondAtom)
		{
			float[] firstAtomAcceleration = new float[3];
            float[] secondAtomAcceleration = new float[3];

            float[] deltaR = new float[3];
            for (int idx = 0; idx < 3; idx++)
            {
                deltaR[idx] = firstAtom.position[idx] - secondAtom.position[idx];
            }
			float distanceSqr = deltaR[0] * deltaR[0] + deltaR[1] *deltaR[1] + deltaR[2] * deltaR[2];
			float finalSigma = StaticVariables.sigmaValues [firstAtom.atomID, secondAtom.atomID];
			float normDistanceSqr = distanceSqr / finalSigma / finalSigma; // this is normalized distanceSqr to the sigmaValue
				
			//only get the forces of the atoms that are within the cutoff range
			if (normDistanceSqr <= StaticVariables.cutoffSqr) 
			{
				int iR = (int) ((float)Math.Sqrt(normDistanceSqr)/(StaticVariables.deltaR));
                for (int idx = 0; idx < 3; idx++)
                {
                    firstAtom.accelerationNew[idx] = firstAtom.accelerationNew[idx] + StaticVariables.preLennardJonesForce[iR] * StaticVariables.accelCoefficient[firstAtom.atomID,secondAtom.atomID] * deltaR[idx];
                    secondAtom.accelerationNew[idx] = secondAtom.accelerationNew[idx] - StaticVariables.preLennardJonesForce[iR] * StaticVariables.accelCoefficient[secondAtom.atomID, firstAtom.atomID] * deltaR[idx];
                }
			}
		}

        //reflect the atoms from the walls
        
        public static void ReflectFromWalls()
        {
            float[] boxDimension = new float[3] {StaticVariables.myEnvironment.depth, StaticVariables.myEnvironment.width , StaticVariables.myEnvironment.height};
            
            for (int i = 0; i < Atom.AllAtoms.Count; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                for (int idx = 0; idx < 3; idx++)
                {
                    float sign = Math.Sign(currAtom.position[idx]);
                    float firstRemainder = ((Math.Abs(currAtom.position[idx]) + boxDimension[idx]/2.0f) % (2.0f * boxDimension[idx]));
                    if (firstRemainder < boxDimension[idx])
                    {
                        currAtom.position[idx] = firstRemainder - boxDimension[idx] / 2.0f;
                        currAtom.velocity[idx] = currAtom.velocity[idx];
                    }
                    else
                    {
                        currAtom.position[idx] = 3.0f * boxDimension[idx] / 2.0f - firstRemainder;
                        currAtom.velocity[idx] = -1.0f * currAtom.velocity[idx];
                    }
                    currAtom.position[idx] = sign * currAtom.position[idx];
                }
                
            }
        }

        public static void CalculateEnergy()
        {
            StaticVariables.potentialEnergy = 0.0f;
            StaticVariables.kineticEnergy = 0.0f;
            StaticVariables.currentTemperature = 0.0f;

            for (int i = 0; i < Atom.AllAtoms.Count - 1; i++)
            {
                Atom firstAtom = Atom.AllAtoms[i];
                
                // calculate kinetic energy of each atom
                float velocitySqr = firstAtom.velocity[0] * firstAtom.velocity[0] + firstAtom.velocity[1] * firstAtom.velocity[1] + firstAtom.velocity[2] * firstAtom.velocity[2];
                StaticVariables.kineticEnergy += 0.5f * firstAtom.massamu * StaticVariables.amuToKg * velocitySqr * StaticVariables.angstromsToMeters * StaticVariables.angstromsToMeters;

                // calculate potential energy between each pair of atoms
                /*
                for (int j = i + 1; j < Atom.AllAtoms.Count; j++)
                {
                    Atom secondAtom = Atom.AllAtoms[j];
                    StaticVariables.potentialEnergy += getLennardJonesPotential(firstAtom, secondAtom);
                }
                */
                
                for (int j = 0; j < firstAtom.neighborList.Count; j++)
                {
                    Atom secondAtom = firstAtom.neighborList[j];
                    StaticVariables.potentialEnergy += getLennardJonesPotential(firstAtom, secondAtom);
                }
                
            }

            StaticVariables.currentTemperature = StaticVariables.kineticEnergy / 1.5f / (float)Atom.AllAtoms.Count / StaticVariables.kB;
            calculateSqrtAlpha();

        }

        //the function returns the Lennard-Jones force on the atom given the list of all the atoms in the simulation
        private static float getLennardJonesPotential(Atom firstAtom, Atom secondAtom)
        {
            float potential = 0.0f;
            float[] deltaR = new float[3];
            for (int idx = 0; idx < 3; idx++)
            {
                deltaR[idx] = firstAtom.position[idx] - secondAtom.position[idx];
            }
            float distanceSqr = deltaR[0] * deltaR[0] + deltaR[1] * deltaR[1] + deltaR[2] * deltaR[2];
            float finalSigma = StaticVariables.sigmaValues[firstAtom.atomID, secondAtom.atomID];
            float normDistanceSqr = distanceSqr / finalSigma / finalSigma; // this is normalized distanceSqr to the sigmaValue

            //only get the forces of the atoms that are within the cutoff range
            if (normDistanceSqr <= StaticVariables.cutoffSqr)
            {
                int iR = (int)((float)Math.Sqrt(normDistanceSqr) / (StaticVariables.deltaR));
                potential = firstAtom.epsilon * StaticVariables.preLennardJonesPotential[iR];
            }
            return potential;
        }

        //this function calculates the coefficient that scales the velocity of atoms to conserve the temperature
        private static void calculateSqrtAlpha()
        {
            float alpha = StaticVariables.desiredTemperature / StaticVariables.currentTemperature;
            float draggedAlpha = 0.0f;
            float draggedTemperature = 0.0f;

            if (StaticVariables.currentTemperature < 0.000000000001f)
            {
                draggedAlpha = 1.0f;
            }
            else if (StaticVariables.currentTemperature > 5000.0f)
            {
                draggedAlpha = alpha;
            }
            else if (alpha > 1)
            {
                draggedTemperature = (StaticVariables.desiredTemperature - StaticVariables.currentTemperature) * StaticVariables.alphaDrag + StaticVariables.currentTemperature;
                draggedAlpha = draggedTemperature / StaticVariables.currentTemperature;
            }
            else if (alpha < 1)
            {
                draggedTemperature = StaticVariables.currentTemperature - ((StaticVariables.currentTemperature - StaticVariables.desiredTemperature) * StaticVariables.alphaDrag);
                draggedAlpha = draggedTemperature / StaticVariables.currentTemperature;
            }
            else
            {
                draggedAlpha = 1.0f;
            }
            StaticVariables.sqrtAlpha = (float)Math.Pow(draggedAlpha, 0.5f);
        }

        public static void calculateVerletRadius()
        {
            // find the the minimum mass of an atom
            float minMassAmu = 10000.0f;
            for (int i = 0; i < Atom.AllAtoms.Count - 1; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                if (minMassAmu > currAtom.massamu)
                {
                    minMassAmu = currAtom.massamu;
                }
            }
            float averageVelocity = (float)Math.Sqrt( 3.0f * StaticVariables.kB * StaticVariables.desiredTemperature / minMassAmu / StaticVariables.amuToKg) / StaticVariables.angstromsToMeters;

            for (int i = 0; i < Atom.AllAtoms.Count - 1; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                //currAtom.verletRadius = StaticVariables.cutoff + 15.0f * (float)StaticVariables.nVerlet * averageVelocity * StaticVariables.MDTimestep / currAtom.sigma;
                currAtom.verletRadius = StaticVariables.cutoff + 1.0f;
                //Console.WriteLine("cutoff radius = " + StaticVariables.cutoff + " , verlet radius = " + currAtom.verletRadius);
            }
        }

        public static void calculateNeighborList()
        {
            //clear the old neighborList
            for (int i = 0; i < Atom.AllAtoms.Count - 1; i++)
            {
                Atom currAtom = Atom.AllAtoms[i];
                currAtom.neighborList.Clear();
            }

            //create the new neighborList
            for (int i = 0; i < Atom.AllAtoms.Count - 1; i++)
            {
                Atom firstAtom = Atom.AllAtoms[i];
                for (int j = i + 1; j < Atom.AllAtoms.Count; j++)
                {
                    Atom secondAtom = Atom.AllAtoms[j];
                    float[] deltaR = new float[3];
                    for (int idx = 0; idx < 3; idx++)
                    {
                        deltaR[idx] = firstAtom.position[idx] - secondAtom.position[idx];
                    }
                    float distanceSqr = deltaR[0] * deltaR[0] + deltaR[1] * deltaR[1] + deltaR[2] * deltaR[2];
                    float finalSigma = StaticVariables.sigmaValues[firstAtom.atomID, secondAtom.atomID];
                    float normDistanceSqr = distanceSqr / finalSigma / finalSigma; // this is normalized distanceSqr to the sigmaValue
                    if (normDistanceSqr < (firstAtom.verletRadius * firstAtom.verletRadius))
                    {
                        firstAtom.neighborList.Add(secondAtom);
                    }
                }
            }
        }

	}
}

